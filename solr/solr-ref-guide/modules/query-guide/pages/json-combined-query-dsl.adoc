= JSON Combined Query DSL
:tabs-sync-option:
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

The Combined Query feature aims to execute multiple queries of multiple kinds across multiple shards of a collection and combine their result basis an algorithm (like Reciprocal Rank Fusion).
It is extending JSON Query DSL ultimately enabling Hybrid Search.

[NOTE]
====
This feature is currently unsupported for grouping and Cursors.
====

[IMPORTANT]
====
This feature works in both Standalone and SolrCloud modes and always performs distributed search execution.
In Standalone (user-managed) mode, shard URLs must be explicitly allow-listed using the *allowUrls* parameter, otherwise Solr returns HTTP 403. For example:

```
"-Dsolr.security.allow.urls=http://localhost:8983/solr/"
```

====

== Configuration Requirements

Combined Query Feature has a separate handler with class `solr.CombinedQuerySearchHandler` which can be configured as below:

```
<requestHandler name="/search" class="solr.CombinedQuerySearchHandler">
.....
</requestHandler>
```

In addition, the `QueryComponent` has been extended to create a new `CombinedQueryComponent`, which must be declared as a search component:
```
<searchComponent class="solr.CombinedQueryComponent" name="combined_query">
    <int name="maxCombinerQueries">2</int>
</searchComponent>
```


The Search Component also accepts parameters as below:

`maxCombinerQueries`::
This parameter can be set to enforce an upper limit on the number of queries defined in `combiner.query`.
It defaults to `5` if not set.


== Query DSL Structure
The query structure is similar to JSON Query DSL except for how multiple queries are defined along with their parameters.

* Multiple queries can be defined under the `queries` key by providing their name with the same syntax as a single query is defined with the key `query`.
* In addition to the other supported parameters, there are several parameters which can be defined under `params` key as below:
`combiner` | Default: `false`::
   Enables the combined query mode when set to `true`.
`combiner.query`::
   The list of queries to be executed as defined in the `queries` key. Example: `["query1", "query2"]`
`combiner.algorithm` | Default: `rrf`::
   The algorithm to be used for combining the results. Reciprocal Rank Fusion (RRF) is the in-built fusion algorithm.
   Any other algorithm can be configured using xref:json-combined-query-dsl.adoc#combiner-algorithm-plugin[plugin].
`combiner.rrf.k` | Default: `60`::
   The k parameter in the RRF algorithm.

=== Example

Below is a sample JSON query payload:

```
{
    "queries": {
        "lexical1": {
            "lucene": {
                "query": "title:sales"
            }
        },
        "vector": {
            "knn": {
                "f": "vector",
                "topK" :5,
                "query": "[0.1,-0.34,0.89,0.02]"
            }
        }
    },
    "limit": 5,
    "fields": ["id", "score", "title"],
    "params": {
        "combiner": true,
        "combiner.query": ["lexical1", "vector"],
        "combiner.algorithm": "rrf",
        "combiner.rrf.k": "15"
    }
}
```

== Combiner Algorithm Plugin

As mentioned xref:json-combined-query-dsl.adoc#query-dsl-structure[above], custom algorithms can be configured to combine the results across multiple queries using a https://solr.apache.org/guide/solr/latest/configuration-guide/solr-plugins.html[Solr plugin].

The class to implement the custom logic has to extend `org.apache.solr.handler.component.combine.QueryAndResponseCombiner`, which is an abstract base class that provides a framework for implementing various algorithms used to merge ranked lists and shard documents.

The Combined Query Component definition takes the `combiners` parameter, where the custom class can be declared by specifying a name and the custom parameters required by the custom algorithm.

Example of the Search Component as below:
```
<searchComponent class="solr.CombinedQueryComponent" name="combined_query">
    <int name="maxCombinerQueries">2</int>
        <lst name="combiners">
           <lst name="customAlgorithm">
                <str name="class">org.apache.solr.handler.component.combine.CustomCombiner</str>
                <int name="customParam1">35</int>
                <str name="customParam2">customValue</str>
            </lst>
        </lst>
</searchComponent>
```

Then, when executing the combined query, the only thing that changes in the JSON query payload is the value specified in the `combiner.algorithm` parameter:

```
    ...
    "params": {
        "combiner": true,
        "combiner.query": ["lexical1", "vector"],
        "combiner.algorithm": "customAlgorithm"
    }
...
```

In this case, `customAlgorithm` is specified which is the name defined in the configuration; the RRF-specific parameters do not need to be provided.

== Additional Resources

Blog posts:

* https://sease.io/2026/03/hybrid-search-with-reciprocal-rank-fusion-in-apache-solr.html[Hybrid Search with Reciprocal Rank Fusion in Apache Solr]
* https://sease.io/2026/03/hybrid-search-using-a-custom-algorithm-in-apache-solr.html[Hybrid Search using a Custom Algorithm in Apache Solr]
