import java.util.function.BiFunction

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Local Lucene development repository resolution:
//   1) A "-Plucene.dev.version=[version]" property, resolving Lucene artifacts from a local Maven repository.
//   2) A non-empty property "-Plucene.dev.path=[path]" pointing to a local path.
//   3) An auto-wired 'lucene' subfolder, if present. To skip auto-wiring, pass
//      a blank value in step 2: "-Plucene.dev.path=".


// This script is applied in settings.gradle and later at build time: these two contexts
// are distinctively different and have separate (and limited) APIs.
def configuringSettings = (rootProject instanceof org.gradle.api.initialization.ProjectDescriptor)

// Accessor for -P properties from settings or at build time.
BiFunction<String, String, String> resolvePropertyValue = { propertyName, defValue ->
  if (configuringSettings) {
    return settings.startParameter.projectProperties.getOrDefault(propertyName, defValue)
  } else {
    return project.properties.getOrDefault(propertyName, defValue)
  }
}

def PROP_FORCE_VERSION="lucene.dev.version"
def PROP_FORCE_PATH="lucene.dev.path"
def READ_ACCESS_PROPERTY="lucene-dev-path.dir"


def forcedLuceneVersion = resolvePropertyValue(PROP_FORCE_VERSION, null)
if (forcedLuceneVersion != null) {
  if (!configuringSettings) {
    logger.lifecycle("Lucene version forced by -P${PROP_FORCE_VERSION}=${forcedLuceneVersion}")

    allprojects {
      repositories {
        mavenLocal()
      }

      tasks.withType(Test) {
        def userHome = System.properties.get('user.home')
        systemProperty READ_ACCESS_PROPERTY, file("${userHome}/.m2/repository/org/apache/lucene").absolutePath
      }

      configurations.all {
        resolutionStrategy.eachDependency {
          if (requested.group == "org.apache.lucene") {
            useVersion(forcedLuceneVersion)
            because("Lucene version forced manually by 'lucene.dev.version' property.")
          }
        }
      }
    }
  }

  // Step 1: end resolution
  return
}

def luceneDevRepo = null
def defaultLuceneDevRepo = file("${rootDir}/lucene")
String propertyValue = resolvePropertyValue(PROP_FORCE_PATH, null)
if (propertyValue != null) {
  // Step 2.
  if (propertyValue.isBlank()) {
    if (defaultLuceneDevRepo.exists() && configuringSettings) {
      logger.lifecycle("Local Lucene development repository has been detected but won't be used.")
    }
  } else {
    luceneDevRepo = file("${propertyValue}").absoluteFile
    if (!luceneDevRepo.exists()) {
      throw new GradleException("Lucene repository does not exist at: -P${PROP_FORCE_PATH}=${luceneDevRepo}.")
    }
  }
} else if (defaultLuceneDevRepo.exists()) {
  // Step 3
  luceneDevRepo = defaultLuceneDevRepo
}


if (luceneDevRepo != null) {
  // Allow turning off this auto-wiring via -Dlucene.dev.repo=false (can't be a -P property because
  // at settings evaluation time we don't have project properties yet).
  if (configuringSettings) {
    // Include Lucene repository as a composite and substitute module names.
    includeBuild(luceneDevRepo) {
      dependencySubstitution {
        def substitutionMap = [
            "org.apache.lucene:lucene-analysis-common"    : ":lucene:analysis:common",
            "org.apache.lucene:lucene-analysis-icu"       : ":lucene:analysis:icu",
            "org.apache.lucene:lucene-analysis-kuromoji"  : ":lucene:analysis:kuromoji",
            "org.apache.lucene:lucene-analysis-morfologik": ":lucene:analysis:morfologik",
            "org.apache.lucene:lucene-analysis-nori"      : ":lucene:analysis:nori",
            "org.apache.lucene:lucene-analysis-opennlp"   : ":lucene:analysis:opennlp",
            "org.apache.lucene:lucene-analysis-phonetic"  : ":lucene:analysis:phonetic",
            "org.apache.lucene:lucene-analysis-smartcn"   : ":lucene:analysis:smartcn",
            "org.apache.lucene:lucene-analysis-stempel"   : ":lucene:analysis:stempel",
            "org.apache.lucene:lucene-backward-codecs"    : ":lucene:backward-codecs",
            "org.apache.lucene:lucene-benchmark"          : ":lucene:benchmark",
            "org.apache.lucene:lucene-classification"     : ":lucene:classification",
            "org.apache.lucene:lucene-codecs"             : ":lucene:codecs",
            "org.apache.lucene:lucene-core"               : ":lucene:core",
            "org.apache.lucene:lucene-demo"               : ":lucene:demo",
            "org.apache.lucene:lucene-expressions"        : ":lucene:expressions",
            "org.apache.lucene:lucene-facet"              : ":lucene:facet",
            "org.apache.lucene:lucene-grouping"           : ":lucene:grouping",
            "org.apache.lucene:lucene-highlighter"        : ":lucene:highlighter",
            "org.apache.lucene:lucene-join"               : ":lucene:join",
            "org.apache.lucene:lucene-memory"             : ":lucene:memory",
            "org.apache.lucene:lucene-misc"               : ":lucene:misc",
            "org.apache.lucene:lucene-monitor"            : ":lucene:monitor",
            "org.apache.lucene:lucene-queries"            : ":lucene:queries",
            "org.apache.lucene:lucene-queryparser"        : ":lucene:queryparser",
            "org.apache.lucene:lucene-replicator"         : ":lucene:replicator",
            "org.apache.lucene:lucene-sandbox"            : ":lucene:sandbox",
            "org.apache.lucene:lucene-spatial-extras"     : ":lucene:spatial-extras",
            "org.apache.lucene:lucene-spatial3d"          : ":lucene:spatial3d",
            "org.apache.lucene:lucene-suggest"            : ":lucene:suggest",
            "org.apache.lucene:lucene-test-framework"     : ":lucene:test-framework"
        ]

        // We have to provide an explicit version to substitute because otherwise
        // all dependencies (including plugin dependencies?!) get substituted.
        String luceneVersion = (file("${rootDir}/versions.props").getText("UTF-8") =~ /org.apache.lucene:\*=(.+)/)[0][1]
        logger.lifecycle("Local Lucene development repository will be used: ${luceneDevRepo}")

        substitutionMap.each { depName, moduleName ->
          substitute(module("${depName}:${luceneVersion}")).using(project(moduleName))
        }
      }
    }
  } else {
    // We're being applied at build-time and Lucene development repository exists. Configure
    // certain aspects of the build so that things work with it.

    // Security policy requires read access to the repo path.
    allprojects {
      tasks.withType(Test) {
        systemProperty READ_ACCESS_PROPERTY, luceneDevRepo.absolutePath
      }
    }
  }
}

